# Semantic Search with Nhost Postgres and OpenAI

The purpose of this guide is to show you how to use Nhost and OpenAI to automatically generate, store, and keep embeddings up-to-date for semantic search.

Nhost is an enterprise-grade open-source platform built on top of GraphQL and PostgreSQL. Nhost offers the convenience of Firebase, with the customization of platforms like Render and Heroku.

Nhost Postgres comes with [pgvector](https://github.com/pgvector/pgvector), which means embeddings can be stored in the same database where application data is stored.

This guide covers how to:

- Start a local instance of Nhost with Postgres & pgvector.
- Configure and start Graphite, Nhost’s AI service.
- Configure Auto-Embeddings to generate and keep embeddings up-to-date automatically.
- Perform semantic search on movies using natural language and GraphQL

> Although this guide uses Graphite to keep embeddings up-to-date, it's possible to manually manage embeddings using Nhost's APIs and Postgres with pgvector.

## Prerequisites

To follow along, make sure you have the following:

1. [Nhost CLI installed](https://docs.nhost.io/development/cli/getting-started#instaling-the-nhost-cli).
2. An [OpenAI API key](https://platform.openai.com/account/api-keys).
3. An OCI-compatible Container Runtime like Docker or Podman.

## Start a local instance of the Nhost stack

In a folder of your choice, create the scaffolding to run a local instance of the Nhost stack with `nhost init`:

```bash
> nhost init
```

`init` creates the following scaffolding for a project's migrations, seeds, and configuration files for API and services:

```bash
> tree -L 2
.
├── functions
├── nhost
│   ├── config.yaml
│   ├── emails
│   ├── metadata
│   ├── migrations
│   ├── nhost.toml
│   └── seeds
```

With a project initialized, start Nhost with `nhost up`:

```bash
> nhost up

Nhost development environment started.

URLs:
- Postgres:             postgres://postgres:postgres@localhost:5432/local
- Hasura:               https://local.hasura.nhost.run
- GraphQL:              https://local.graphql.nhost.run
- Auth:                 https://local.auth.nhost.run
- Storage:              https://local.storage.nhost.run
- Functions:            https://local.functions.nhost.run
- Dashboard:            https://local.dashboard.nhost.run
- Mailhog:              https://local.mailhog.nhost.run

SDK Configuration:
 Subdomain:             local
 Region:                (empty)

Run `nhost up` to reload the development environment
Run `nhost down` to stop the development environment
Run `nhost logs` to watch the logs
```

The output shows a list of URLs for all the services started.

> `nhost up` starts a fully-fledged instance of Nhost with Postgres+pgvector, generated GraphQL APIs, authentication, and storage services, plus a runtime for functions and custom services.

You can use the [Nhost Dashboard](https://local.dashboard.nhost.run/local/local/database/browser) to manage your database, users, files, and more.

## Create the schema for storing movies and embeddings

To create a table for storing movies, open the [database SQL Editor](https://local.dashboard.nhost.run/local/local/database/browser/default/editor) and run the following SQL with **"Track this" enabled**:

```sql
CREATE TABLE "public"."movies" (
    "id" uuid NOT NULL DEFAULT gen_random_uuid(),
    "createdAt" timestamptz NOT NULL DEFAULT now(),
    "name" text NOT NULL,
    "genre" text NOT NULL,
    "overview" text NOT NULL,
    PRIMARY KEY ("id")
);
```

With "Track this" enabled, Nhost will automatically generate GraphQL APIs for the `movies` table.

Next, run the following SQL to enable the `pgvector` extension, add the columns `embedding` and `outdated` to `movies`, and create a trigger to manage when embeddings become outdated:

```sql
SET ROLE postgres;
CREATE EXTENSION IF NOT EXISTS vector;
RESET ROLE;

ALTER TABLE "movies" ADD COLUMN "embedding" vector(1536);
ALTER TABLE "movies" ADD COLUMN "outdated" boolean DEFAULT true;

-- Create a trigger that sets "outdated" to true if the columns "name", "genre", or "overview" are updated
CREATE OR REPLACE FUNCTION set_outdated_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.name <> OLD.name OR NEW.genre <> OLD.genre OR NEW.overview <> OLD.overview THEN
        NEW.outdated := true;
    ELSEIF NEW.embedding IS NOT NULL THEN
        NEW.outdated := false;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to the table
CREATE TRIGGER set_outdated
BEFORE UPDATE ON "movies"
FOR EACH ROW
EXECUTE FUNCTION set_outdated_trigger();
```

In addition to the colums for storing movie data, the `movies` table now has two additional columns:

- `embedding` - a vector(1536) column for storing vectors generated by OpenAI.
- `outdated` - a boolean flag used to infer whether a movie is outdated and needs to have its embedding vector regenerated by Graphite.

Finally, a trigger is created to set `outdated` to `true` if any of the columns `name`, `genre`, or `overview` are updated.

How these columns are used by Graphite will become clear soon. The important bit to understand now is that the logic to manage how embeddings become outdated is entirely up to the user.

### Load movies with a seed file

To load movies into the `movies` table, copy the `imdb_movies.sql` file [attached to this guide]() into the seeds folder of your Nhost project (`./nhost/seeds/default`).

With the file in place, run the following command to seed the database:

```bash
> nhost up --apply-seeds
```

Verify that the `movies` table was correctly seeded by looking at the [database explorer](https://local.dashboard.nhost.run/local/local/database/browser/default/public/movies) and finding some of your favourite movies.

Notice the `embedding` column is `null` (no vector has been generated yet) and `outdated` is true.

## Enable Graphite

Graphite, written in Go, integrates with OpenAI and the Nhost ecosystem, giving your application superpowers. Graphite has support for Auto-Embeddings (used in this guide), AI Assistants, and Developer Assistant.

To enable Graphite, update `nhost/nhost.toml` and add the following section:

```toml
[ai]
version = '0.4.0' # Graphite version
webhookSecret = 'this-is-a-webhook-secret'

[ai.resources]
[ai.resources.compute]
cpu = 256
memory = 512

[ai.openai]
organization = ''
apiKey = '{{ secrets.OPENAI_API_KEY }}'

[ai.autoEmbeddings]
# Checks for outdated embeddings every `syncPeriodMinutes`
synchPeriodMinutes = 1
```

Nhost's Configuration file, `nhost.toml`, is where all configuration of a Nhost project lives, and how we ensure environment parity between local and cloud instances.

> Read more about [Nhost Config](https://nhost.io/blog/config).

Note that `apiKey` references a [secret](https://docs.nhost.io/platform/secrets). Secrets for local instances are added to the file `.secrets` present in the root of the project. Add your [OpenAI API key](https://platform.openai.com/api-keys) to `.secrets`:

```
OPENAI_API_KEY=sk-...
```

For the new configuration to take place, Nhost needs to reload it. Run the following command to reload Nhost with the new configuration:

```bash
nhost up
```

To confirm that Graphite is running, you can inspect its logs:

```bash
nhost logs -f ai
```

## Setup Auto-Embeddings

Graphite needs the following information to generate & keep embeddings up-to-date:

- A database column to store vector embeddings.
- A GraphQL query to fetch outdated records from the database.
- A GraphQL mutation for updating outdated database records with new embedding vectors.

With the AI service enabled, [open the dashboard and add the following configuration to Auto-Embeddings](https://local.dashboard.nhost.run/local/local/ai/auto-embeddings):

**Name**: movies

**Schema**: public

**Table**: movies

**Column**: embedding

**Query**:

```graphql
query GetOutdatedMovies {
  movies(
    where: {
      _or: [{ embedding: { _is_null: true } }, { outdated: { _eq: true } }]
    }
  ) {
    id # required
    name
    genre
    overview
  }
}
```

**Mutation**:

```graphql
mutation UpdateEmbeddingsMovie($id: uuid!, $embeddings: vector) {
  update_movies_by_pk(
    pk_columns: { id: $id }
    _set: { embedding: $embeddings }
  ) {
    __typename
  }
}
```

In summary:

- A `Name` for the Auto-Embedding.
- A `column` (with schema and table name) where embeddings are stored.
- A query to fetch outdated database records: `GetOutdatedMovies` returns all movies with `outdated` set to `true` or movies that haven’t had their embeddings generated. **The fields returned by the query are the fields Graphite generates embeddings for.**
- A mutation to update a record with a new embedding vector: `UpdateEmbeddingsMovie`.

### Generating and Storing OpenAI embeddings

Once the configuration for Auto-Embeddings is added, Graphite will start generating embeddings for all movies. You can monitor the progress by checking the logs (`nhost logs -f ai`) or by looking at the `embedding` column in the `movies` table. This process may take a few minutes.

Graphite does the following:

1. it starts by calling `GetOutdatedMovies` to get a list of movies that need to have their embedding updated.
2. for each movie, it will ask [OpenAI’s Embeddings API](https://platform.openai.com/docs/guides/embeddings) to generate a vector representation of the movie data.
3. finally, it updates the movie data with the newly generated embedding vector, by calling the `UpdateEmbeddingsMovie` mutation.

Every time a movie is updated, graphite will make sure to regenerate its embedding if necessary.

Recall the following configuration from the section **Enable Graphite:**

```toml
[ai.autoEmbeddings]
synchPeriodMinutes = 1
```

The setting `synchPeriodMinutes` tells Graphite to look for and update outdated embeddings every minute. This configuration should be tweaked depending on the application and requirements.

## Using generated-GraphQL queries for semantic search

We have seen how easy it is to generate and keep embeddings up-to-date with very little effort.

In addition to generating embeddings, Graphite also generates GraphQL queries for semantic search and similarity search. These queries can be used to search and compare objects based on their embeddings.

For the `movies` table, Graphite generated the queries:

- `graphiteSearchMovies` (`graphiteSearch[Name]`) to search movies using natural language (e.g. "comedy in space").
- `graphiteSimilarMovies` (`graphiteSimilar[Name]`) to compare movies using similarity search.

Where `[Name]` is the name of the Auto-Embedding configuration.

To use these queries, open the [GraphQL editor](https://local.dashboard.nhost.run/local/local/graphql) in the dashboard and run the following query to search for movies about comedy in space:

```graphql
query SimilarMovies {
  graphiteSearchMovies(args: { query: "comedy in space", amount: 5 }) {
    name
  }
}
```

```json
{
  "data": {
    "graphiteSearchMovies": [
      {
        "name": "Linoleum"
      },
      {
        "name": "Project Gemini"
      },
      {
        "name": "King Shakir Recycle"
      },
      {
        "name": "Space Jam: A New Legacy"
      },
      {
        "name": "Doraemon: Nobita's Little Star Wars 2021"
      }
    ]
  }
}
```

The query returns a list of movies that match the search query "comedy in space".

Now, let's run a query for similarity search. The following query searches for movies similar to `Space Jam: A New Legacy`:

```graphql
query SimilarMoviesTo {
  graphiteSimilarMovies(
    args: { id: "9123ca69-d3bf-4c24-9388-34f913b4904b", amount: 5 }
  ) {
    name
  }
}
```

```json
{
  "data": {
    "graphiteSimilarMovies": [
      {
        "name": "The Super Mario Bros. Movie"
      },
      {
        "name": "Mummies"
      },
      {
        "name": "Supercell"
      },
      {
        "name": "Cocaine Bear"
      },
      {
        "name": "Avatar: The Way of Water"
      }
    ]
  }
}
```

The query returns a list of movies similar to `Space Jam: A New Legacy`.

Both queries respect the same permissions as the remaining API - only results the user is allowed to see are returned.

Don't forget to check the [documentation for Graphite](https://docs.nhost.io/graphite) for more information and other features.
